#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Make sure to change the paths to your TRACER folder!

@author: muellerM@ieg-mainz.de
"""

import argparse
import subprocess
import shlex    # Splits shell command into a list (for subprocess)
from pathlib import Path
from datetime import datetime
import sys
import os
import shutil
import re

# Define path to TRACER depending on the operating system.
# (This is the directory where "tracer.jar" lives.)
if sys.platform in ["linux", "linux1", "linux2"]:
    tracer_path = str(Path("/…PATH_TO_TRACER…/tracer-linux/tracer/"))
elif sys.platform == "win32":
    tracer_path = str(Path("C:/…PATH_TO_TRACER…/tracer-windows/tracer-master/"))
print("INFO  Current TRACER path:", tracer_path)


def init_argparse():
    """ Returns a parser that processes the arguments from the command line. """
    parser = argparse.ArgumentParser(
            usage="%(prog)s [FILE.tsv]",
            description=""" Runs TRACER on the given FILE. Make sure the file has the correct format (see TRACER manual). """
        )

    parser.add_argument(
            "file", nargs=1, type=str
        )

    parser.add_argument(
            "-o", "--output_directory", default="tracer_output",
            help="Directory where TRACER's output (score file, HTML etc.) should be stored."
        )
    
    parser.add_argument(
            "-p", "--tracer_path", default=tracer_path,
            help=f"Root path of the TRACER directory. Default = {tracer_path}"
        )
    
    return parser

class TRACER:
    def __init__(self, input_file, tracer_path, output_directory):
        self.input_file = input_file
        self.tracer_path = tracer_path
        self.output_directory = output_directory

        self.tracer_data_directory = self.create_tracer_data_directory()
        self.cwd = os.getcwd()
        self.tracer_config_file = Path(self.tracer_path, "conf", "tracer_config.xml")
        self.tracer_input_file = Path(self.tracer_path, self.tracer_data_directory, self.input_file)
        self.tracer_memory = "2g"  # memory TRACER can use
        self.tracer_results_path = None # will be generated by self.get_results_path after TRACER has finished its calculations

    def create_tracer_data_directory(self):
        # Build directory name:
        corpus_name = Path(self.input_file).stem
        timestamp = datetime.now().strftime('%Y-%m-%dT%H-%M-%S')
        directory = Path(self.tracer_path, "data/corpora", f"{corpus_name},_{timestamp}")

        # Create the directory:
        try:
            os.mkdir(directory)
            print(f"INFO  Successfully created {directory}")
            return str(directory)
        except:
            print(f"ERROR creating {directory}")
            print(sys.exc_info()[0])
            raise

    def copy_input_file(self):
        """ Copy the input file into the data directory. 
            Returns the relative path of the input file. """
        try:
            shutil.copyfile(Path(self.input_file), self.tracer_input_file)
            print("INFO  Successfully copied input file to data directory.")
            return True
        except:
            print("ERROR: Could not copy input file to data directory.")
            raise

    def update_config_file(self):
        """ Modifies the TRACER config file: 
            - SENTENCE_FILE_NAME = input file
            """
        input_file_pattern = '(<property name="SENTENCE_FILE_NAME" value=")(.*?)(" />)'
        
        def repl(match):
            return match.group(1) + str(self.tracer_input_file) + match.group(3)
        
        try:
            with open(self.tracer_config_file, "r", encoding="utf-8") as f:
                config_file = f.read()
            
            config_file = re.sub(input_file_pattern, repl, config_file)
            
            with open(self.tracer_config_file, "w", encoding="utf-8") as o:
                o.write(config_file)
            print("INFO  Modified TRACER config file successfully.")
            return True
        except:
            print("ERROR: Could not modify config file!")
            raise

    def run(self, jar="tracer.jar", verbose=True):
        """ Executes TRACER. """
        os.chdir(self.tracer_path) # Go to TRACER directory
        process = subprocess.Popen(shlex.split(f"java -Xmx{self.tracer_memory} -Deu.etrap.medusa.config.ClassConfig={self.tracer_config_file} -jar {jar}"),
                                stdout=subprocess.PIPE,  # Catch program output
                                stderr=subprocess.PIPE,  # Catch error output
                                universal_newlines=True) # Make output UTF-8
        while True:
            if verbose:
                # Continously print the output …
                output = process.stdout.readline()
                print(output.strip())
            return_code = process.poll()
            #     … until we get the return code:
            if return_code is not None:
                print("\nRETURN CODE", return_code, "\n")
                os.chdir(self.cwd) # Go back to the previous directory
                # Print the remaining output:
                for output in process.stdout.readlines():
                    print(output.strip())
                errors = process.stderr.readlines()
                if errors != []:
                    print("ERRORS:")
                    for error in errors:
                        print(error)
                    return False
                return True

    def get_results_path(self):
        """ Searches the subdirectories of the tracer_data_directory for 
            the directory containing the results of TRACER's data analysis. """

        results_path = Path(self.tracer_data_directory, "TRACER_DATA")
        try:
            # Let's dig five levels down into the tree of nested directories:
            for level in [0,0,0,0,0]: # the numbers define which subfolder to go into
                results_path = [x for x in results_path.glob("*") if x.is_dir()][level]
            print(f"INFO  Found tracer_results_path :-)")
            self.tracer_results_path = results_path
        except:
            print("ERROR Couldn't find the results path!")
            raise

    def collect_results(self):
        """ Collect the results and copy them to the
            results directory. """
        
        self.get_results_path()

        output_folder = Path(self.tracer_data_directory).parts[-1]
        output_folder = Path(self.output_directory, output_folder)

        # Create the local results directory:
        try:
            os.mkdir(output_folder)
        except:
            print(f"ERROR Could not create output_folder = {output_folder}")
            raise

        # Copy the input file:
        try:
            shutil.copyfile(Path(self.input_file), Path(output_folder, Path(self.input_file).parts[-1]))
            print("INFO  Successfully copied input file to results directory.")
        except:
            print("ERROR: Could not copy input file to results directory.")
            raise
        
        # Copy TRACER's score file:
        try:
            score_file = [x for x in self.tracer_results_path.glob('*.score')][-1]
            shutil.copyfile(score_file, Path(output_folder, f"{Path(self.input_file).stem}.score"))
            print("INFO  Successfully copied score file to results directory.")
        except:
            print("ERROR: Could not copy score file to results directory.")
            raise

        # Copy TRACER's HTML output:
        try:
            # Search the folder containing TRACER's HTML output:
            html_path = [x for x in self.tracer_results_path.glob('*') if x.is_dir()][-1]
            # Check if html_path is empty:
            if any(html_path.iterdir()):
                # Copy it:
                shutil.copytree(Path(html_path), Path(output_folder, "html"))
                print("INFO  Successfully copied TRACER's HTML output to results directory.")
            else:
                print("ERROR: TRACER did not produce HTML output!")
        except:
            print("ERROR: Could not copy TRACER's HTML output to results directory.")
            raise

def main():
    parser = init_argparse()
    args = parser.parse_args()
    input_file = args.file[0]
    results_subdirectory = args.output_directory

    tracer = TRACER(input_file, tracer_path, results_subdirectory)

    tracer.copy_input_file()
    tracer.update_config_file()

    tracer.run()
    tracer.collect_results()
    print(f"INFO  Finished analyzing {input_file}!")

if __name__ == "__main__":
    main()
